<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Health Assistant | College Project</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom styles for professional look and feel */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7fafc; /* Light gray background */
        }
        #chat-window {
            height: 70vh;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .message-bubble {
            max-width: 85%;
            padding: 12px 18px;
            border-radius: 20px;
            margin-bottom: 15px;
            line-height: 1.5;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }
        .user-message {
            background-color: #3b82f6; /* Blue for user */
            color: white;
            border-bottom-right-radius: 5px;
        }
        .ai-message {
            background-color: #ffffff; /* White for AI */
            border: 1px solid #e5e7eb;
            color: #1f2937;
            border-bottom-left-radius: 5px;
        }
        /* Style for the structured summary box */
        .summary-box {
            background-color: #f0fdf4; /* Light green background */
            border: 1px solid #d1fae5;
            padding: 15px;
            border-radius: 12px;
            margin-top: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .summary-box strong {
            color: #047857; /* Dark green for emphasis */
        }
        .action-button {
            transition: all 0.2s;
        }
        .action-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        /* Loader styles */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3b82f6;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Header & Safety Disclaimer -->
    <header class="bg-red-600 text-white p-4 shadow-lg sticky top-0 z-10">
        <div class="max-w-4xl mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold">üíä AI Health Assistant</h1>
            <span class="text-sm font-medium">College Project by [Your Name]</span>
        </div>
        <div class="mt-2 text-center bg-red-700 p-2 rounded-lg text-sm font-semibold">
            ‚ö†Ô∏è DISCLAIMER: This is an AI tool for informational purposes only. It is **NOT** medical advice. Always consult a qualified doctor.
        </div>
    </header>

    <!-- Main Chat Area -->
    <main class="flex-grow max-w-4xl mx-auto w-full p-4">
        <div id="chat-window" class="bg-gray-50 p-4 rounded-xl border border-gray-200 shadow-inner">
            <!-- Initial welcome message -->
            <div class="flex justify-start">
                <div class="ai-message message-bubble">
                    <strong class="text-red-600">üõë I am an AI and not a doctor. Please consult a qualified healthcare professional for medical advice.</strong>
                    <p class="mt-1">Hello! I can provide general health information and summaries. What health topic or symptom would you like to discuss today?</p>
                </div>
            </div>
        </div>
        
        <!-- Action Buttons Area -->
        <div id="action-area" class="flex justify-center space-x-4 mt-4 mb-2">
            <button id="summarize-btn" class="action-button bg-green-500 text-white px-4 py-2 rounded-full font-semibold shadow-md opacity-50 cursor-not-allowed" disabled>
                <i class="fas fa-file-alt"></i> Structured Summary
            </button>
            <button id="tts-btn" class="action-button bg-purple-500 text-white px-4 py-2 rounded-full font-semibold shadow-md opacity-50 cursor-not-allowed" disabled>
                <i class="fas fa-volume-up"></i> Read Tip Aloud
            </button>
            <audio id="tts-audio" src="" class="hidden"></audio>
        </div>

    </main>

    <!-- Input Area -->
    <footer class="bg-white p-4 border-t border-gray-200 sticky bottom-0 w-full shadow-2xl">
        <div class="max-w-4xl mx-auto flex items-center space-x-3">
            <input type="text" id="user-input" placeholder="Ask a health-related question..." 
                   class="flex-grow p-3 border border-gray-300 rounded-full focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition duration-150">
            
            <button id="send-btn" class="bg-blue-600 text-white p-3 rounded-full hover:bg-blue-700 transition duration-150 shadow-lg flex items-center justify-center w-12 h-12">
                <i class="fas fa-paper-plane"></i>
            </button>
            <div id="loader-container" class="hidden">
                <div class="loader"></div>
            </div>
        </div>
    </footer>

    <!-- JavaScript Logic -->
    <script>
        // --- DOM Elements ---
        const chatWindow = document.getElementById('chat-window');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const loaderContainer = document.getElementById('loader-container');
        const summarizeBtn = document.getElementById('summarize-btn');
        const ttsBtn = document.getElementById('tts-btn');
        const ttsAudio = document.getElementById('tts-audio');

        // --- State Management ---
        let chatHistory = [];
        let lastAiMessage = '';
        let isProcessing = false;

        // --- API Constants ---
        // Crucial: The frontend calls YOUR secure backend proxy, not the Gemini API directly.
        // This is the route Vercel/Netlify will expose your secure api/chat.js file at.
        const CHAT_ENDPOINT = '/api/chat';
        
        // --- Utility Functions ---
        
        // Scrolls the chat window to the bottom
        function scrollToBottom() {
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        // Enables or disables the input and buttons during processing
        function setProcessingState(processing) {
            isProcessing = processing;
            userInput.disabled = processing;
            sendBtn.disabled = processing;
            if (processing) {
                loaderContainer.classList.remove('hidden');
                sendBtn.classList.add('hidden');
            } else {
                loaderContainer.classList.add('hidden');
                sendBtn.classList.remove('hidden');
            }
        }
        
        // Enables action buttons (TTS and Summarize) only after a successful AI response
        function enableActionButtons(messageContent) {
            lastAiMessage = messageContent;
            summarizeBtn.disabled = false;
            ttsBtn.disabled = false;
            summarizeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            ttsBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        }

        // Disables action buttons
        function disableActionButtons() {
            lastAiMessage = '';
            summarizeBtn.disabled = true;
            ttsBtn.disabled = true;
            summarizeBtn.classList.add('opacity-50', 'cursor-not-allowed');
            ttsBtn.classList.add('opacity-50', 'cursor-not-allowed');
        }

        // Creates a message bubble in the chat window
        function createMessageBubble(text, role, sources = []) {
            const bubbleContainer = document.createElement('div');
            bubbleContainer.classList.add('flex', role === 'user' ? 'justify-end' : 'justify-start');

            const bubble = document.createElement('div');
            bubble.classList.add('message-bubble', role === 'user' ? 'user-message' : 'ai-message');
            
            // Use DOMPurify if this were a real production app to sanitize HTML, but for this project, 
            // we'll rely on innerHTML for markdown rendering.
            bubble.innerHTML = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');

            if (sources.length > 0) {
                const sourceDiv = document.createElement('div');
                sourceDiv.classList.add('mt-2', 'text-xs', 'text-gray-500', 'border-t', 'pt-2');
                sourceDiv.innerHTML = '<strong>Sources:</strong>';
                sources.forEach((source, index) => {
                    const link = document.createElement('a');
                    link.href = source.uri;
                    link.textContent = source.title || `Source ${index + 1}`;
                    link.target = '_blank';
                    link.classList.add('block', 'truncate', 'hover:text-blue-600');
                    sourceDiv.appendChild(link);
                });
                bubble.appendChild(sourceDiv);
            }

            bubbleContainer.appendChild(bubble);
            chatWindow.appendChild(bubbleContainer);
            scrollToBottom();
            return bubble;
        }

        // --- Main Chat Function ---

        async function sendMessage() {
            if (isProcessing) return;
            const prompt = userInput.value.trim();
            if (!prompt) return;

            // 1. Display user message
            createMessageBubble(prompt, 'user');
            userInput.value = '';
            setProcessingState(true);
            disableActionButtons();

            try {
                // 2. Prepare payload for secure backend
                const payload = { 
                    prompt: prompt,
                    chatHistory: chatHistory 
                };

                // 3. Send request to YOUR secure backend
                const response = await fetch(CHAT_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                const candidate = result.candidates?.[0];
                const aiText = candidate?.content?.parts?.[0]?.text;
                
                let sources = [];
                const groundingMetadata = candidate?.groundingMetadata;
                if (groundingMetadata?.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title);
                }


                if (aiText) {
                    // 4. Update chat history and display AI message
                    chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                    chatHistory.push({ role: "model", parts: [{ text: aiText }] });
                    createMessageBubble(aiText, 'model', sources);
                    enableActionButtons(aiText); // Enable summary/TTS buttons
                } else {
                    // Handle case where AI response is empty or blocked
                    createMessageBubble("Sorry, I could not process that request or the content was blocked due to safety settings. Please try a different query.", 'model');
                }

            } catch (error) {
                console.error("Chat Error:", error);
                createMessageBubble(`An error occurred: ${error.message}. Please check your browser console for details or ensure your GEMINI_API_KEY is set correctly on the server.`, 'model');
            } finally {
                setProcessingState(false);
            }
        }

        // --- Action Button Functions (Using Gemini API for Structured Data and TTS) ---

        // Function for Step 1: Exponential Backoff for Retries
        async function fetchWithRetry(url, options, maxRetries = 5) {
            let delay = 1000; // 1 second
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (response.ok) return response;
                    if (response.status === 429 || response.status >= 500) {
                        // Rate limit or server error, retry after delay
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; // Exponential backoff
                        continue;
                    }
                    // Non-retryable error
                    return response;
                } catch (error) {
                    // Network error, retry after delay
                    await new Promise(resolve => setTimeout(resolve, delay));
                    delay *= 2;
                }
            }
            throw new Error(`Failed to fetch ${url} after ${maxRetries} attempts.`);
        }


        // 1. Structured Summary Function
        async function getStructuredSummary() {
            if (!lastAiMessage) return;

            // Temporarily disable buttons
            summarizeBtn.disabled = true;
            const originalText = summarizeBtn.innerHTML;
            summarizeBtn.innerHTML = '<i class="fas fa-sync-alt fa-spin"></i> Generating...';

            // Construct the prompt to ask for structured data
            const structurePrompt = `Analyze the following health information and structure it into three distinct parts: 'Key Symptoms' (bullet points), 'Potential Causes' (bullet points), and 'General Safety Advice' (a short paragraph). The text to analyze is: "${lastAiMessage}"`;
            
            // NOTE: For a real deployment, this JSON generation should also go through a secure backend proxy
            // to ensure the key is hidden. For simplicity in this single-file app structure, 
            // we will simulate the structure request, as we don't have a structured proxy setup here.
            // In a full environment, you would call a new secure endpoint like /api/summary.
            
            // **For demonstration purposes in this front-end file:** We will fake the structured response 
            // to show how it should be rendered after receiving it from a secure proxy.
            
            try {
                 // **THIS BLOCK IS SIMULATED FOR FRONTEND DEMO**
                await new Promise(resolve => setTimeout(resolve, 1500)); // Fake network delay

                const fakeStructuredResponse = {
                    KeySymptoms: [
                        "Fever (usually low-grade)", 
                        "Fatigue or tiredness", 
                        "Sore throat", 
                        "Aches and pains"
                    ],
                    PotentialCauses: [
                        "Common viral infections (e.g., Rhinovirus)", 
                        "Minor bacterial irritations", 
                        "Allergies or environmental factors"
                    ],
                    GeneralSafetyAdvice: "If symptoms worsen, last more than three days, or include severe difficulty breathing, seek immediate medical attention. Rest and hydration are essential for recovery."
                };
                
                // **END SIMULATED BLOCK**


                // 2. Render the structured data
                let summaryHtml = `
                    <p class="text-lg font-bold mb-3 text-gray-800">‚ú® Structured Health Summary</p>
                    
                    <div class="mb-4">
                        <strong class="text-base block mb-1">Key Symptoms:</strong>
                        <ul class="list-disc list-inside ml-2 text-sm">
                            ${fakeStructuredResponse.KeySymptoms.map(s => `<li>${s}</li>`).join('')}
                        </ul>
                    </div>

                    <div class="mb-4">
                        <strong class="text-base block mb-1">Potential Causes:</strong>
                        <ul class="list-disc list-inside ml-2 text-sm">
                            ${fakeStructuredResponse.PotentialCauses.map(c => `<li>${c}</li>`).join('')}
                        </ul>
                    </div>

                    <div>
                        <strong class="text-base block mb-1">General Safety Advice:</strong>
                        <p class="text-sm">${fakeStructuredResponse.GeneralSafetyAdvice}</p>
                    </div>
                `;
                
                const bubbleContainer = document.createElement('div');
                bubbleContainer.classList.add('flex', 'justify-start');

                const bubble = document.createElement('div');
                bubble.classList.add('message-bubble', 'ai-message', 'summary-box');
                bubble.innerHTML = summaryHtml;
                
                bubbleContainer.appendChild(bubble);
                chatWindow.appendChild(bubbleContainer);
                scrollToBottom();

                // Update last message to the summary so TTS can read it
                lastAiMessage = `The structured summary is: ${fakeStructuredResponse.GeneralSafetyAdvice}`;


            } catch (error) {
                console.error("Summary Error:", error);
                createMessageBubble(`Failed to generate summary: ${error.message}`, 'model');
            } finally {
                summarizeBtn.innerHTML = originalText;
                summarizeBtn.disabled = false;
            }
        }

        // 2. Text-to-Speech (TTS) Function
        async function readTextAloud() {
            if (!lastAiMessage) return;

            ttsBtn.disabled = true;
            const originalText = ttsBtn.innerHTML;
            ttsBtn.innerHTML = '<i class="fas fa-volume-up"></i> Loading Audio...';
            ttsAudio.pause();
            ttsAudio.removeAttribute('src');

            const TTS_MODEL_NAME = "gemini-2.5-flash-preview-tts";
            const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL_NAME}:generateContent?key=`; // Key will be provided by Canvas runtime

            // Simple text cleanup for better TTS quality
            const textToSpeak = lastAiMessage.replace(/[\*\#\n]/g, ' ').substring(0, 1000); // Limit length

            const payload = {
                contents: [{
                    parts: [{ text: `Say in a calm, informative voice: ${textToSpeak}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Rasalgethi" } // Informative voice
                        }
                    }
                }
            };

            try {
                // Call the TTS API (Note: This is one of the few APIs that can be called directly from the frontend in this environment)
                const response = await fetchWithRetry(TTS_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    throw new Error(`TTS API failed with status ${response.status}`);
                }

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType; // audio/L16;rate=24000

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)?.[1] || 24000, 10);
                    
                    // Helper function to convert base64 to ArrayBuffer
                    const base64ToArrayBuffer = (base64) => {
                        const binaryString = atob(base64);
                        const len = binaryString.length;
                        const bytes = new Uint8Array(len);
                        for (let i = 0; i < len; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        return bytes.buffer;
                    };

                    // Helper function to convert PCM data to WAV Blob (required for playback)
                    const pcmToWav = (pcm16, sampleRate) => {
                        const buffer = new ArrayBuffer(44 + pcm16.length * 2);
                        const view = new DataView(buffer);
                        
                        // RIFF chunk descriptor
                        writeString(view, 0, 'RIFF');
                        view.setUint32(4, 36 + pcm16.length * 2, true); // ChunkSize
                        writeString(view, 8, 'WAVE');
                        
                        // FMT sub-chunk
                        writeString(view, 12, 'fmt ');
                        view.setUint32(16, 16, true); // Subchunk1Size
                        view.setUint16(20, 1, true); // AudioFormat (1 is PCM)
                        view.setUint16(22, 1, true); // NumChannels
                        view.setUint32(24, sampleRate, true); // SampleRate
                        view.setUint32(28, sampleRate * 2, true); // ByteRate (SampleRate * NumChannels * 2)
                        view.setUint16(32, 2, true); // BlockAlign (NumChannels * 2)
                        view.setUint16(34, 16, true); // BitsPerSample
                        
                        // DATA sub-chunk
                        writeString(view, 36, 'data');
                        view.setUint32(40, pcm16.length * 2, true); // Subchunk2Size
                        
                        // Write the PCM data
                        let offset = 44;
                        for (let i = 0; i < pcm16.length; i++, offset += 2) {
                            view.setInt16(offset, pcm16[i], true);
                        }

                        return new Blob([view], { type: 'audio/wav' });
                    };

                    const writeString = (view, offset, string) => {
                        for (let i = 0; i < string.length; i++) {
                            view.setUint8(offset + i, string.charCodeAt(i));
                        }
                    };
                    
                    const pcmData = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmData);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    ttsAudio.src = audioUrl;
                    ttsAudio.play();

                    ttsAudio.onended = () => {
                        ttsBtn.innerHTML = originalText;
                        ttsBtn.disabled = false;
                    };
                    
                } else {
                    throw new Error("TTS response was empty or malformed.");
                }

            } catch (error) {
                console.error("TTS playback error:", error);
                createMessageBubble(`Could not play audio: ${error.message}`, 'model');
                ttsBtn.innerHTML = originalText;
                ttsBtn.disabled = false;
            }
        }


        // --- Event Listeners ---
        sendBtn.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        summarizeBtn.addEventListener('click', getStructuredSummary);
        ttsBtn.addEventListener('click', readTextAloud);


    </script>
</body>
</html>
